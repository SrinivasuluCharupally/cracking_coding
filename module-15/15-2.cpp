//Context Switch: How would you measure the time spent in a context switch?

// Ans : 
context switch is the time spent switching between two processes (i.e., bringing a waiting process into execution and sending an executing process into waiting/terminated state). This happens in multitasking. The operating system must bring the state information of waiting processes into memory and save the state information of the currently running process.In order to solve this problem, we would like to record the timestamps of the last and  first instruction of the swapping processes. The context switch time is the diference in the timestamps between the two processes.

Let's take an easy example: Assume there are only two processes, P1 and P2•

let's assume it happens at the Nth instruction of P1. If tx,k indicates the timestamp in microseconds of the kth instruction of process x, then the context switch would take t2,1 - t1,n microseconds.The tricky part is this: how do we know when this swapping occurs? We cannot, of course, record the time­ stamp of every instruction in the process.Another issue is that swapping is governed by the scheduling algorithm of the operating system and there may be many kernel level threads which are also doing context switches. Other processes could be contending for the CPU or the kernel handling interrupts. The user does not have any control over these extraneous context switches. For instance, if at time t1,n the kernel decides to handle an interrupt, then the context switch time would be overstated.In order to overcome these obstacles, we must  first construct an environment such that after P1 executes, the task scheduler immediately selects P2 to run. This may be accomplished by constructing a data channel, such as a pipe, between P1 and P2 and having the two processes play a game of ping-pong with a data token.That is, let's allow P1 to be the initial sender and P2 to be the receiver. Initially, P2 is blocked (sleeping) as it awaits the data token. When P1 executes, it delivers the token over the data channel to P2 and immediately attempts to read a response token. However, since P2 has not yet had a chance to run, no such token is avail­ able for P1 and the process is blocked. This relinquishes the CPU.A context switch results and the task scheduler must select another process to run. Since P2 is now in a ready-to-run state, it is a desirable candidate to be selected by the task scheduler for execution. When P2 runs, the roles of P1 and P2 are swapped. P2 is now acting as the sender and P1 as the blocked receiver. The game ends when P2 returns the token to P1•To summarize, an iteration of the game is played with the  following steps:1. P2blocksawaitingdatafromP1•2. P1marksthestarttime.3. P1 sends token to P2•4. P1attemptstoreadaresponsetokenfromP2•Thisinducesacontextswitch. 5. P2isscheduledandreceivesthetoken.6. P2sendsaresponsetokentoP1•7. P2attemptsreadaresponsetokenfromP1•Thisinducesacontextswitch. 8. P1isscheduledandreceivesthetoken.9. P1markstheendtime.The key is that the delivery of a data token induces a context switch. Let Td and Tr be the time it takes to deliver and receive a data token, respectively, and let Tc be the amount of time spent in a context switch. At step2,P1 recordsthetimestampofthedeliveryofthetoken,andatstep9,itrecordsthetimestampofthe response. The amount of time elapsed, T, between these events may be expressed by:T=2*(Td +Tc +Tr)This formula arises because of the following events: P1 sends a token (3), the CPU context switches (4), P2receives it (5). P2 then sends the response token (6), the CPU context switches (7), and  nally P1 receives itp isexecutingandP iswaitingforexecution.Atsomepoint,theoperatingsystemmustswapP1andP2-(8).

